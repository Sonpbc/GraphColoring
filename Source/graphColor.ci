mainmodule Module {
  include "vertex.h";
  include "graphColor.h";

  readonly CProxy_Main mainProxy;
  readonly AdjListType adjList_;
  readonly int vertices_;
  readonly int chromaticNum_;

mainchare Main {
    entry Main(CkArgMsg*);
    entry [reductiontarget] void done(void);
  };
  
  chare Node { 
    entry Node(bool, int, CProxy_Node);
    entry Node(std::vector<vertex>, bool, int, CProxy_Node);
    entry void testGraph(std::vector<vertex>&);
    entry void succeed(bool, std::vector<vertex>);

    entry void run(){
        atomic { 
            //-----DEBUG USE BELOW--------
            //this->printGraph();
            //-----DEBUG USE ABOVE--------

            //for now, THRESHOLD is set to 1
            //colorLocally() choose the first available color
            //for the remaining 1 vertex
            if(uncolored_num_ <= THRESHOLD){
                bool res = colorLocally();
                parent_.succeed(res, node_state_);
                return;
            }

            //get the vertex to color
            int vIndex = this->getNextConstraintVertex();
            
            boost::dynamic_bitset<> possibleColor(
                node_state_[vIndex].getPossibleColor());
            //child_num_ = possibleColor.count();
            child_num_ = 1;

            //test whehter colorable or not
            //return false if uncolorable
            if(!possibleColor.any()){
                parent_.succeed(false, node_state_);
                return;
            }

            //---------DEUBG USE BELOW------------
            CkPrintf("try to color vertex[%d] with %d colors\n",
                vIndex, possibleColor.count());
            //--------DEBUG USE ABOVE-------------

            // for each possible color
            // try it and create corresponding node state
            // to fire children
            for(boost::dynamic_bitset<>::size_type c=0;
                c<possibleColor.size(); c++){
                //if the color is not possible, skip it
                if(!possibleColor.test(c))
                    continue;

                //get possible color c, and color it
                //update neighbor's possible_color_
                std::vector<vertex> new_state = node_state_;
                updateState(new_state, vIndex, c);
                //fire new child
                CProxy_Node child = CProxy_Node::ckNew
                    (new_state, false, uncolored_num_-1, thisProxy);
                break;
            }
        }

        // when one of the child finishes
        // passback to parent to merge the graph
        // for now, it's unneccesary to notify parent.
        // But it's needed in later optimization
        while(true){
            when succeed(bool res, std::vector<vertex> state) atomic{
                child_finished_ ++;
                if(res==true){
                    if(is_root_){
                        printGraph();
                        CkExit();
                    } else {
                        parent_.succeed(true, state);
                    }
                    return;
                } else if(child_finished_==child_num_){
                    parent_.succeed(false, state);
                    return;
                }
            }
        }

    };
  };
};
