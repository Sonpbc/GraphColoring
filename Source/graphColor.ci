mainmodule Module {
  include "vertex.h";
  include "graphColor.h";

  readonly CProxy_Main mainProxy;
  readonly AdjListType adjList_;
  readonly int vertices_;
  readonly int chromaticNum_;

mainchare Main {
    entry Main(CkArgMsg*);
    entry [reductiontarget] void done(void);
  };
  
  chare Node { 
    entry Node(bool, int, CProxy_Node);
    entry Node(std::vector<vertex>, bool, int, CProxy_Node);
    entry void testGraph(std::vector<vertex>&);
    entry void finish(bool, std::vector<vertex>);

    entry void run(){
        atomic { 
            //-----DEBUG USE BELOW--------
            //this->printGraph();
            //-----DEBUG USE ABOVE--------

            /* For a given chare if the number of uncolored vertices is below a
             * threshold then it colors them locally using a naive sequential
             * algorithm. (for now, THRESHOLD is set to 1).
             */

            if(uncolored_num_ <= THRESHOLD){
                colorLocally();
                return;
            } else {
                colorRemotely();
            }
        }

        /* When  one of the child finishes, either it finds the solution or
         * gets into an dead end, it notifies its parent.  In the former case
         * the parent can either propagate the victory information to its
         * parent(in case of OR tree) or wait for another children to respond (in case of AND tree).
         * Also the parent needs to make sure that all the other chares should stop
         * evaluating their subtrees.
         */

        while(true){
            when finish(bool res, std::vector<vertex> state) atomic{
                
                child_finished_ ++;

                bool waitChild = mergeToParent(res, state);
                if(!waitChild)
                    return;
            }
        }

    };
  };
};
